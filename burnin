#!/bin/bash
# burnin - StressDisk drive burn-in helper for Debian/Proxmox
# Features:
#   - whiptail checkbox menu to select drives
#   - Skips RAID/ZFS/mounted drives unless --force
#   - Subcommands: status | stop | clean | report
#   - Global kill-switch (for main runs)
#   - Default = verify mode (SAFE)
#   - Typed confirmations for destructive actions
#   - SMART logs before/after
#   - Background SMART temperature sampling during run
#   - Temperature min/max and color-coded summary in report
#   - --dry mode to simulate everything without touching disks
#
# Updates (added on top of the original):
#   - New subcommands: resume [drive] | list
#   - Background runs are de-prioritized (nohup + ionice + nice) and tracked with PID‚Üídrive mapping
#   - Foreground mode option with interactive progress gauge (max resources) + summary on completion
#   - Elapsed-time tracking for runs (shown in list/stop)
#   - Dependency check remains fail-fast, but now prints install guidance

set -euo pipefail

LOGDIR="/var/log/stressdisk"
MNTROOT="/mnt/stress"

mkdir -p "$LOGDIR" "$MNTROOT"

# ---------- Utilities ----------
color() { # usage: color red "text"
  case "$1" in
    red)    printf "\033[1;31m%s\033[0m" "$2" ;;
    green)  printf "\033[1;32m%s\033[0m" "$2" ;;
    yellow) printf "\033[1;33m%s\033[0m" "$2" ;;
    blue)   printf "\033[1;34m%s\033[0m" "$2" ;;
    *)      printf "%s" "$2" ;;
  esac
}

die() { echo "‚ùå $*" >&2; exit 1; }

have() { command -v "$1" >/dev/null 2>&1; }

# ---------- Helpers ----------
elapsed_time() {
  if [ -f "$LOGDIR/starttime.txt" ]; then
    local start now secs
    start=$(cat "$LOGDIR/starttime.txt")
    now=$(date +%s)
    secs=$((now - start))
    printf "%02d:%02d:%02d" $((secs/3600)) $((secs%3600/60)) $((secs%60))
  else
    echo "N/A"
  fi
}

smart_dump() { local d=$1; local when=$2; smartctl -a "/dev/$d" > "$LOGDIR/${d}-smart-${when}.log" 2>&1 || true; }

# ---------- Subcommands (no kill-switch needed) ----------
show_status()  { echo "========= StressDisk Status ========="; ps aux | grep '[s]tressdisk' || true; }

# stop_all now supports PID‚Üídrive mapping file
stop_all()     {
  echo "========= Stopping StressDisk ========="
  if [ -f "$LOGDIR/pids.txt" ]; then
    awk '{print $1}' "$LOGDIR/pids.txt" | xargs -r kill 2>/dev/null || true
    rm -f "$LOGDIR/pids.txt"
  fi
  pkill -9 stressdisk 2>/dev/null || true
  echo
  echo "========= Summary ========="
  echo "Elapsed time       : $(elapsed_time)"
}

clean_all()    {
  echo "========= Cleaning StressDisk mounts ========="
  for m in "$MNTROOT"/*; do
    [ -d "$m" ] || continue
    stressdisk clean "$m" 2>/dev/null || true
    umount "$m" 2>/dev/null || true
  done
}

report_all()   {
  echo "========= Burn-In SMART & Temperature Report ========="
  echo

  local ok_count=0 warn_count=0 fail_count=0
  shopt -s nullglob
  for before in "$LOGDIR"/*-smart-before.log; do
    local drive after log tempslog
    drive=$(basename "$before" | sed 's/-smart-before.log//')
    after="$LOGDIR/${drive}-smart-after.log"
    log="$LOGDIR/${drive}.log"
    tempslog="$LOGDIR/${drive}-temps.log"

    if [ ! -f "$after" ]; then
      echo -e "‚ö†Ô∏è  $(color yellow "No after-test log for /dev/$drive (maybe still running)")"
      warn_count=$((warn_count+1))
      echo
      continue
    fi

    echo -e "$(color blue "Drive: /dev/$drive")"
    echo "----------------------------------------"

    local drive_status="ok"
    local ATTRS="Reallocated Pending Offline Uncorrect CRC Temperature"
    for attr in $ATTRS; do
      local b a
      b=$(grep -i "$attr" "$before" | tail -n1 || true)
      a=$(grep -i "$attr" "$after"  | tail -n1 || true)
      if [ -n "$b" ] && [ -n "$a" ]; then
        if [ "$b" != "$a" ]; then
          echo -e "‚ö†Ô∏è  $(color yellow "$attr changed:")"
          echo "   Before: $b"
          echo "   After : $a"
          [ "$drive_status" = "ok" ] && drive_status="warn"
          if [[ "$attr" =~ ^(Reallocated|Pending|Offline)$ ]]; then
            drive_status="fail"
          fi
        else
          echo -e "   $(color green "$attr unchanged") ($a)"
        fi
      fi
    done

    echo
    echo "Temperature during test:"
    if [ -f "$tempslog" ] && [ -s "$tempslog" ]; then
      # temps.log lines: "YYYY-MM-DD HH:MM:SS N"
      local min max
      min=$(awk '{print $NF}' "$tempslog" | grep -E '^[0-9]{2,3}$' | sort -n | head -1 || true)
      max=$(awk '{print $NF}' "$tempslog" | grep -E '^[0-9]{2,3}$' | sort -n | tail -1 || true)
      if [ -n "$max" ]; then
        if [ "$max" -ge 60 ]; then
          echo -e "   üö® $(color red "Max: ${max}¬∞C (too hot!)")"
          drive_status="fail"
        elif [ "$max" -ge 55 ]; then
          echo -e "   ‚ö†Ô∏è  $(color yellow "Max: ${max}¬∞C (warm)")"
          [ "$drive_status" = "ok" ] && drive_status="warn"
        else
          echo -e "   $(color green "Max: ${max}¬∞C")"
        fi
        [ -n "$min" ] && echo "   Min: ${min}¬∞C"
      else
        echo "   (No numeric temps parsed)"
      fi
    else
      echo "   (No temp samples recorded)"
    fi

    echo
    case "$drive_status" in
      ok)   ok_count=$((ok_count+1)) ;;
      warn) warn_count=$((warn_count+1)) ;;
      fail) fail_count=$((fail_count+1)) ;;
    esac
  done
  shopt -u nullglob

  echo "========= Summary ========="
  echo -e "üü¢ OK: $ok_count"
  echo -e "‚ö†Ô∏è  Warning: $warn_count"
  echo -e "üö® Failed: $fail_count"
  echo
}

# NEW: resume [drive] ‚Üí tail logs live (all or specific drive)
resume_logs() {
  local target="${1:-}"

  echo "========= Live Burn-In Logs ========="
  echo

  if [ -n "$target" ]; then
    local logfile="$LOGDIR/${target}.log"
    if [ -f "$logfile" ]; then
      echo -e "üìÑ $(color blue "$logfile")"
      tail -n 20 -f "$logfile"
    else
      echo "‚ùå No logfile found for /dev/$target"
    fi
  else
    shopt -s nullglob
    local any=0
    for logfile in "$LOGDIR"/*.log; do
      any=1
      echo -e "üìÑ $(color blue "$logfile")"
      tail -n 20 -f "$logfile" &
    done
    shopt -u nullglob
    [ $any -eq 0 ] && echo "‚ö†Ô∏è  No logs found in $LOGDIR"
    wait || true
  fi
}

# NEW: list ‚Üí show PID‚Üídrive mappings + running state + elapsed
list_jobs() {
  echo "========= Active Burn-In Jobs ========="
  echo

  if [ ! -f "$LOGDIR/pids.txt" ]; then
    echo "‚ö†Ô∏è  No active job mappings found."
  else
    while read -r pid drive; do
      if [ -z "${pid:-}" ] || [ -z "${drive:-}" ]; then
        continue
      fi
      if kill -0 "$pid" 2>/dev/null; then
        echo -e "üü¢ PID $pid ‚Üí /dev/$drive (log: $LOGDIR/$drive.log)"
      else
        echo -e "üî¥ PID $pid ‚Üí /dev/$drive (not running)"
      fi
    done < "$LOGDIR/pids.txt"
  fi

  echo
  echo "========= Summary ========="
  if [ -f "$LOGDIR/pids.txt" ]; then
    echo "Total jobs tracked : $(wc -l < "$LOGDIR/pids.txt")"
  else
    echo "Total jobs tracked : 0"
  fi
  echo "Elapsed time       : $(elapsed_time)"
}

case "${1:-}" in
  status) show_status; exit 0;;
  stop)   stop_all;   exit 0;;
  clean)  clean_all;  exit 0;;
  report) report_all; exit 0;;
  resume) shift; resume_logs "$@"; exit 0;;
  list)   list_jobs; exit 0;;
esac

# ---------- Global kill-switch (only for main runs) ----------
echo -e "$(color red "‚ö†Ô∏è  WARNING: This tool can ERASE DISKS if used in destructive modes.")"
read -r -p "Type 'yes' to continue, or anything else to quit: " global_confirm
if [[ "$global_confirm" != "yes" ]]; then
  echo "‚ùå Exiting safely. No action taken."
  exit 1
fi

# ---------- Dependency check (fail fast + guidance) ----------
missing=()
have whiptail    || missing+=("whiptail")
have smartctl    || missing+=("smartmontools")
have stressdisk  || missing+=("stressdisk")

if [ ${#missing[@]} -ne 0 ]; then
  echo "‚ùå Missing required packages/binaries: ${missing[*]}"
  echo
  echo "To install the missing dependencies, run:"
  echo "  sudo apt update && sudo apt install -y whiptail smartmontools"
  echo
  echo "For stressdisk:"
  echo "  # Download the latest binary (x86_64):"
  echo "  ver=\$(curl -s https://api.github.com/repos/ncw/stressdisk/releases/latest | grep tag_name | cut -d '\"' -f4 | sed 's/^v//')"
  echo "  curl -L -o /usr/local/bin/stressdisk https://github.com/ncw/stressdisk/releases/download/v\${ver}/stressdisk_linux_x86_64"
  echo "  chmod +x /usr/local/bin/stressdisk"
  echo
  echo "  # Or build via Go:"
  echo "  sudo apt install -y golang && GOBIN=/usr/local/bin go install github.com/ncw/stressdisk@latest"
  echo
  exit 1
fi

# ---------- Flags (main run) ----------
FORCE=false
DRYRUN=false
case "${1:-}" in
  --force) FORCE=true; shift ;;
  --dry)   DRYRUN=true; shift ;;
esac

# ---------- Detect candidate disks ----------
# list raw "disk" devices; we'll mark in-use later
mapfile -t ALL_DISKS < <(lsblk -ndo NAME,TYPE | awk '$2=="disk"{print $1}')

# helpers to mark in-use states (same behavior as original)
is_in_zfs()  { have zpool && zpool status 2>/dev/null | grep -qE "(^|\s)/dev/$1(\s|$)"; }
is_in_md()   {
  # linux_raid_member fstype OR mention in /proc/mdstat
  if lsblk -ndo FSTYPE "/dev/$1" 2>/dev/null | grep -qi linux_raid_member; then return 0; fi
  grep -q "$1" /proc/mdstat 2>/dev/null
}
is_mounted_tree() { lsblk -rno MOUNTPOINT "/dev/$1" 2>/dev/null | grep -q '/'; }

# ---------- Build whiptail checklist ----------
DRIVE_OPTIONS=()
INUSE_FLAGS=()   # parallel array: "1" if in-use, else "0"
for i in "${!ALL_DISKS[@]}"; do
  d="${ALL_DISKS[$i]}"
  dev="/dev/$d"
  label="$dev"
  inuse=0

  is_in_md "$d"        && { label+=" ‚ö†Ô∏èRAID";    inuse=1; }
  is_in_zfs "$d"       && { label+=" ‚ö†Ô∏èZFS";     inuse=1; }
  is_mounted_tree "$d" && { label+=" ‚ö†Ô∏èMOUNTED"; inuse=1; }

  INUSE_FLAGS[$i]=$inuse
  if $FORCE; then
    DRIVE_OPTIONS+=("$i" "$label" "OFF")
  else
    # whiptail can't actually disable items; we'll filter later
    [ $inuse -eq 1 ] && label+=" (SKIPPED)"
    DRIVE_OPTIONS+=("$i" "$label" "OFF")
  fi
done

CHOICES=$(whiptail --title "Burn-In Drive Selector" --checklist \
"Space = select, arrows = move, Enter = continue" \
20 70 15 \
"${DRIVE_OPTIONS[@]}" 3>&1 1>&2 2>&3) || { echo "Canceled."; exit 1; }

# Turn selections into TARGETS, applying skip filter if not --force
TARGETS=()
for choice in $CHOICES; do
  idx=$(echo "$choice" | tr -d '"')
  if [ "${INUSE_FLAGS[$idx]}" = "1" ] && ! $FORCE; then
    echo "Skipping in-use device /dev/${ALL_DISKS[$idx]} (RAID/ZFS/MOUNTED). Use --force to override."
    continue
  fi
  TARGETS+=("${ALL_DISKS[$idx]}")
done

[ ${#TARGETS[@]} -gt 0 ] || die "No drives selected."

# ---------- Duration & mode ----------
read -r -p "How many hours to run? (default 24): " hours
hours=${hours:-24}
DURATION="${hours}h"

echo
echo "Test modes:"
echo "  1) run    ‚Üí write random files, verify (‚ö†Ô∏è DESTRUCTIVE)"
echo "  2) cycle  ‚Üí repeatedly fill/erase (‚ö†Ô∏è DESTRUCTIVE, SSD wear)"
echo "  3) verify ‚Üí verify existing files only (SAFE, default)"
read -r -p "Choose test mode [1-3]: " mode_choice
case "${mode_choice:-3}" in
  1) MODE="run" ;;
  2) MODE="cycle" ;;
  3|"") MODE="verify" ;;
  *) MODE="verify" ;;
esac

# ---------- Safety prompts (unchanged behavior) ----------
warn_and_confirm() {
  local d=$1; local action=$2
  echo -e "$(color red "‚ö†Ô∏è  WARNING: This will $action on /dev/$d")"
  echo "This may cause DATA LOSS."
  read -r -p "Type '/dev/$d' to confirm, or anything else to cancel: " typed
  [[ "$typed" == "/dev/$d" ]]
}

# preserve original prep (optional format + mount)
smart_dump()    { local d=$1; local when=$2; smartctl -a "/dev/$d" > "$LOGDIR/${d}-smart-${when}.log" 2>&1 || true; }

prep_drive() {
  local d=$1
  echo "== PREPPING /dev/$d =="
  read -r -p "Do you want to format /dev/$d before testing? (yes/no): " confirm
  if [[ "$confirm" == "yes" ]]; then
    warn_and_confirm "$d" "WIPE and FORMAT" || { echo "‚ùå Skipping /dev/$d"; return 1; }
    $DRYRUN && { echo "(dry-run) Would wipe and format /dev/$d"; return 0; }
    wipefs -a "/dev/$d"
    mkfs.ext4 -F -L "STRESS_$d" "/dev/$d"
  fi
  mkdir -p "$MNTROOT/$d"
  if ! mountpoint -q "$MNTROOT/$d"; then
    $DRYRUN && { echo "(dry-run) Would mount /dev/$d at $MNTROOT/$d"; return 0; }
    mount "/dev/$d" "$MNTROOT/$d"
  fi
}

# ---------- Background vs Foreground selection (NEW) ----------
echo
read -r -p "Run in background (safe) or foreground (max resources)? [b/f]: " RUNMODE
[[ "$RUNMODE" =~ ^[bf]$ ]] || die "Invalid choice."

# ---------- Temperature sampler (works for both modes) ----------
sample_temps() {
  local d=$1
  local pid_match="$2"   # optional PID, preferred when available
  while :; do
    if [ -n "${pid_match:-}" ]; then
      kill -0 "$pid_match" 2>/dev/null || break
    else
      # Fallback: detect any stressdisk working on this mount path
      pgrep -f "stressdisk.*${MNTROOT}/${d}" >/dev/null || break
    fi
    local ts temp
    ts=$(date +'%F %T')
    temp=$(smartctl -a "/dev/$d" 2>/dev/null | \
           grep -E 'Temperature(_Celsius)?|Airflow_Temperature|Composite Temperature|Temperature:' | \
           grep -Eo '[0-9]{2,3}' | head -1)
    if [[ -n "${temp:-}" ]]; then
      echo "$ts $temp" >> "$LOGDIR/${d}-temps.log"
    fi
    sleep 300
  done
}

# ---------- Run functions ----------
run_stress_background() {
  local d=$1 dur=$2 mode=$3

  if [[ "$mode" == "run" || "$mode" == "cycle" ]]; then
    warn_and_confirm "$d" "RUN StressDisk in '$mode' mode (writes over data)" || { echo "‚ùå Skipping /dev/$d"; return 1; }
  fi

  if $DRYRUN; then
    echo "(dry-run) Would run StressDisk on /dev/$d for $dur in $mode mode"
    return 0
  fi

  prep_drive "$d" || return 1

  echo "== Capturing SMART baseline for /dev/$d =="
  smart_dump "$d" "before"

  echo "== STARTING StressDisk on /dev/$d for $dur ($mode) =="
  # De-prioritized to avoid host impact
  nohup ionice -c2 -n7 nice -n 19 \
    stdbuf -oL -eL stressdisk -duration "$dur" -logfile "$LOGDIR/$d.log" "$mode" "$MNTROOT/$d" \
    >> "$LOGDIR/$d.log" 2>&1 &

  local pid=$!
  echo "$pid $d" >> "$LOGDIR/pids.txt"

  # background: wait for completion, then SMART after
  ( wait "$pid" || true
    echo "== Capturing SMART after test for /dev/$d =="
    smart_dump "$d" "after"
  ) &

  # background: temperature sampler
  ( sample_temps "$d" "$pid" ) &
}

run_stress_foreground() {
  local d=$1 dur=$2 mode=$3

  if [[ "$mode" == "run" || "$mode" == "cycle" ]]; then
    warn_and_confirm "$d" "RUN StressDisk in '$mode' mode (writes over data)" || { echo "‚ùå Skipping /dev/$d"; return 1; }
  fi

  if $DRYRUN; then
    echo "(dry-run) Would run StressDisk on /dev/$d for $dur in $mode mode (foreground)"
    return 0
  fi

  prep_drive "$d" || return 1

  echo "== Capturing SMART baseline for /dev/$d =="
  smart_dump "$d" "before"

  echo "== RUNNING (foreground) StressDisk on /dev/$d for $dur ($mode) =="
  # Full-speed foreground; still write a logfile; parse % for gauge
  stdbuf -oL -eL stressdisk -duration "$dur" -logfile "$LOGDIR/$d.log" "$mode" "$MNTROOT/$d" 2>&1 | \
  tee -a "$LOGDIR/$d.log" | \
  awk '
    {
      # Emit any N% token as a gauge value
      while (match($0, /([0-9]+)%/, m)) {
        print m[1];
        $0 = substr($0, RSTART+RLENGTH);
        fflush();
      }
    }
  ' | whiptail --gauge "Burn-in progress for /dev/$d" 8 70 0

  echo "== Capturing SMART after test for /dev/$d =="
  smart_dump "$d" "after"

  # temp sampling: attempt a brief sweep after completion to record last values
  ( sample_temps "$d" "" ) &
}

foreground_summary() {
  echo
  echo "========= Foreground Burn-In Summary ========="
  echo

  for d in "${TARGETS[@]}"; do
    local before="$LOGDIR/${d}-smart-before.log"
    local after="$LOGDIR/${d}-smart-after.log"
    local tempslog="$LOGDIR/${d}-temps.log"

    [ -f "$before" ] || continue

    echo -e "$(color blue "/dev/$d")"
    echo "----------------------------------------"

    local drive_status="ok"
    local ATTRS="Reallocated Pending Offline Uncorrect CRC Temperature"
    for attr in $ATTRS; do
      local b=$(grep -i "$attr" "$before" | tail -n1 || true)
      local a=$(grep -i "$attr" "$after"  | tail -n1 || true)
      if [ -n "$b" ] && [ -n "$a" ] && [ "$b" != "$a" ]; then
        echo -e "‚ö†Ô∏è  $(color yellow "$attr changed:")"
        echo "   Before: $b"
        echo "   After : $a"
        drive_status="warn"
        [[ "$attr" =~ ^(Reallocated|Pending|Offline)$ ]] && drive_status="fail"
      fi
    done

    if [ -f "$tempslog" ] && [ -s "$tempslog" ]; then
      local min max
      min=$(awk '{print $NF}' "$tempslog" | sort -n | head -1 || true)
      max=$(awk '{print $NF}' "$tempslog" | sort -n | tail -1 || true)
      if [ -n "$max" ]; then
        if [ "$max" -ge 60 ]; then
          echo -e "   üö® $(color red "Max Temp: ${max}¬∞C (too hot!)")"
          drive_status="fail"
        elif [ "$max" -ge 55 ]; then
          echo -e "   ‚ö†Ô∏è  $(color yellow "Max Temp: ${max}¬∞C (warm)")"
          [ "$drive_status" = "ok" ] && drive_status="warn"
        else
          echo -e "   $(color green "Max Temp: ${max}¬∞C")"
        fi
        [ -n "$min" ] && echo "   Min Temp: ${min}¬∞C"
      fi
    fi

    case "$drive_status" in
      ok)   echo -e "Status: üü¢ $(color green "OK")" ;;
      warn) echo -e "Status: ‚ö†Ô∏è  $(color yellow "Warning")" ;;
      fail) echo -e "Status: üö® $(color red "Failed")" ;;
    esac
    echo
  done
}

# ---------- Execute ----------
if $DRYRUN; then
  echo
  echo "========= DRY RUN PLAN ========="
  echo "Mode     : (will prompt)"
  echo "Duration : $DURATION"
  echo "Targets  : ${TARGETS[*]/#/\/dev/}"
  echo "‚ö†Ô∏è  No disks will be touched."
  # still ask run mode for completeness, but do nothing destructive
fi

echo
read -r -p "Run in background (safe) or foreground (max resources)? [b/f]: " RUNMODE2
# If user typed earlier, keep that; otherwise use new answer
if [[ ! "$RUNMODE" =~ ^[bf]$ ]]; then
  RUNMODE="$RUNMODE2"
  [[ "$RUNMODE" =~ ^[bf]$ ]] || die "Invalid choice."
fi

if [ "$RUNMODE" = "b" ]; then
  for d in "${TARGETS[@]}"; do
    run_stress_background "$d" "$DURATION" "$MODE"
  done
  if ! $DRYRUN; then
    date +%s > "$LOGDIR/starttime.txt"
  fi
  echo
  echo "========= Burn-In Started ========="
  echo "Mode     : $MODE"
  echo "Duration : $DURATION"
  echo "Targets  : ${TARGETS[*]/#/\/dev/}"
  echo "Logs     : $LOGDIR/<disk>.log"
  echo "SMART    : $LOGDIR/<disk>-smart-before.log / <disk>-smart-after.log"
  echo "Temps    : $LOGDIR/<disk>-temps.log (5-min samples)"
  echo "PIDs     : $LOGDIR/pids.txt   # format: '<pid> <disk>'"
  echo
  echo "Commands:"
  echo "  burnin status   ‚Üí show running jobs"
  echo "  burnin list     ‚Üí list PID‚Üídrive, running state, elapsed time"
  echo "  burnin resume   ‚Üí tail logs (all or one drive: 'burnin resume sdb')"
  echo "  burnin stop     ‚Üí stop all StressDisk jobs"
  echo "  burnin clean    ‚Üí unmount & clean test files"
  echo "  burnin report   ‚Üí compare SMART before/after + temps (summary)"
else
  for d in "${TARGETS[@]}"; do
    run_stress_foreground "$d" "$DURATION" "$MODE"
  done
  foreground_summary
fi

